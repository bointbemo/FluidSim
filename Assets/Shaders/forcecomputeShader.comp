#version 440

#define WORK_GROUP_SIZE 7200
#define NUM_PARTICLES 7200
#define PARTICLE_RADIUS 0.1f
// constants


#define PI 3.1415927410125732421875f

#define PARTICLE_DENSITY_START 1000
#define PARTICLE_VISCOSITY 10
#define PARTICLE_MASS 0.7
#define SMOOTHING_LENGTH (0.158460189*6.8)
#define GRAVITY vec4(0, -9.81,0,0)

#define PARTICLE_STIFFNESS 3
// For calculations


layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct Particle
{
 	     float x; //position
			float y;
			float z;
			
			
			float velocityx;//velocity
			float velocityy;
			float velocityz;
		
			float forcex;//force
			float forcey;
			float forcez;
			
			
			float density;//density
			float dempty;
			
			float pressure;//presure
			float pempty; //llambda

			float correction_forcex;
			float correction_forcey;
			float correction_forcez;
    
};

layout(std430, binding = 1) buffer PARTICLES
{
Particle particles[];
};
layout(std430, binding = 2) buffer SOLIDS
{
Particle solids[];
};



const float GAS_CONST = 2000.0f; // const for equation of state



void main()
{
    uint i = gl_GlobalInvocationID.x;  
    // compute all forces
    vec3 pressure_force = vec3(0, 0,0);
    vec3 viscosity_force = vec3(0, 0,0);
    vec3 surface_force = vec3(0,0,0);
    vec3 correction_pressure_force = vec3(0, 0,0);
    vec3 correction_viscosity_force = vec3(0, 0,0);
     vec3 delta = vec3(0,0,0);
     vec3 normal = vec3(0,0,0);
     vec3 localParticlej = vec3(0,0,0);
     vec3 localParticlei = vec3(0,0,0);
     vec3 particlejVelocity = vec3(0,0,0);
     vec3 particleiVelocity = vec3(0,0,0);
     vec3 contactVelocity = vec3(0,0,0);
     float impulseVelocity =  0;
     vec3 fullimpulseVelocity = vec3(0,0,0);
     vec4 external_force = vec4(0,0,0,0);
     float r = 0.0f;
     int considered_particles = 0;
     int considered_particles1 = 0;
     float modgradient = 0;
     vec3 gradient = vec3(0,0,0);
   
    for ( int j = 0; j < NUM_PARTICLES; j++)
    {
        if(particles[j].density==0){particles[j].density = 1000;};
        if(particles[i].density==0){particles[i].density = 1000;};
        if (i == j)
        {
            continue;
        }
     vec3 positioni = vec3(particles[i].x,particles[i].y,particles[i].z);
     vec3 positionj = vec3(particles[j].x, particles[j].y, particles[j].z);
     
        delta = positionj-positioni;
         r = length(delta);
        if(r<PARTICLE_RADIUS){//collision corrections, if particle j within radius of i repel out as fluid is incompressable
            //particles[j].x = particles[j].x + PARTICLE_RADIUS;
            //particles[j].y = particles[j].y + PARTICLE_RADIUS;
           //particles[j].z = particles[j].z + PARTICLE_RADIUS;#
           if(considered_particles1<10){
            normal = normalize(vec3(delta.x,delta.y,delta.z));
           localParticlej = normal * PARTICLE_RADIUS;
localParticlei = -normal * PARTICLE_RADIUS;
particleiVelocity = vec3(particles[i].velocityx,particles[i].velocityy,particles[i].velocityz);
particlejVelocity = vec3(particles[j].velocityx,particles[j].velocityy,particles[j].velocityz);
contactVelocity = particleiVelocity - particlejVelocity;
impulseVelocity = (contactVelocity.x * normal.x + contactVelocity.y * normal.y + contactVelocity.z* normal.z)/PARTICLE_MASS;
fullimpulseVelocity = normal*impulseVelocity;
 if(r == 0){r = 0.01;};
 particles[i].velocityx =  particles[i].velocityx  +fullimpulseVelocity.x  * ((PARTICLE_RADIUS-r)/PARTICLE_RADIUS);
particles[i].velocityy = particles[i].velocityy  + fullimpulseVelocity.y  *  ((PARTICLE_RADIUS-r)/PARTICLE_RADIUS) ;
particles[i].velocityz = particles[i].velocityz  + fullimpulseVelocity.z * (PARTICLE_RADIUS-r/PARTICLE_RADIUS) ;
/* particles[j].velocityx =  particles[j].velocityx + fullimpulseVelocity.x *(r/PARTICLE_RADIUS) *0.001;
particles[j].velocityy = particles[j].velocityy + fullimpulseVelocity.y  *(r/PARTICLE_RADIUS) ;
particles[j].velocityz = particles[j].velocityz + fullimpulseVelocity.z * (r/PARTICLE_RADIUS) *0.001; */
           
           
          
            //particles[j].velocityx =  -particles[j].velocityx * (r/PARTICLE_RADIUS);
           // particles[j].velocityy = -particles[j].velocityy* (r/PARTICLE_RADIUS);
           // particles[j].velocityz =  -particles[j].velocityz* (r/PARTICLE_RADIUS);

            //delta = positionj-positioni;
            //r = length(delta); 
           }

        }
        
        if (r < SMOOTHING_LENGTH)
        {
            if(particles[j].density==0){particles[j].density=1000;};
            
            pressure_force += PARTICLE_MASS * 
            ((positioni - positionj)/r) *
            ((particles[i].pressure / (particles[i].density*2) + particles[j].pressure/ (particles[j].density*2)))*
            // gradient of spiky kernel from muller et al 2003
                 ((15/(PI*pow(SMOOTHING_LENGTH,6)) *pow(SMOOTHING_LENGTH-r, 3))) ;
            
            if(pow(r,2)>0){
            viscosity_force += PARTICLE_VISCOSITY*PARTICLE_MASS * 
            ((vec3(particles[j].velocityx,particles[j].velocityy,particles[j].velocityz) - vec3(particles[i].velocityx,particles[i].velocityy,particles[i].velocityz)) 
            / particles[j].density )*
            // Laplacian of viscosity kernel from muller et al 2003
                (45.f / (PI * pow(SMOOTHING_LENGTH, 6)) * (SMOOTHING_LENGTH - r));
            }
                 correction_pressure_force -= (particles[i].pempty+particles[j].pempty)*PARTICLE_MASS *
                 ((positionj - positioni)/r) *
                  (particles[i].pressure + particles[j].pressure) 
                  / pow(( particles[j].density),2) *
            // gradient of spiky kernel from muller et al 2003
                 ((15/(PI*pow(SMOOTHING_LENGTH,6)) *pow(SMOOTHING_LENGTH-r, 3))) ;
            
            if(pow(r,2)>0){
            correction_viscosity_force += (particles[i].pempty+particles[j].pempty)* PARTICLE_MASS * (vec3(particles[j].velocityx,particles[j].velocityy,particles[j].velocityz) - vec3(particles[i].velocityx,particles[i].velocityy,particles[i].velocityz)) / particles[j].density *
            // Laplacian of viscosity kernel from muller et al 2003
                45.f / (PI * pow(SMOOTHING_LENGTH, 6)) * (SMOOTHING_LENGTH - r);
                
            }
           
           
        }
         considered_particles++;

            if(considered_particles == 50){continue;}; 
    }
         
if(considered_particles<20){
    
for ( int j = 0; j < NUM_PARTICLES; j++){
                
  vec3 positioni = vec3(particles[i].x,particles[i].y,particles[i].z);
  vec3 positionj = vec3(particles[j].x, particles[j].y, particles[j].z);
  delta = positioni-positionj;
  r = length(delta);
   if(r<SMOOTHING_LENGTH){
    if(particles[j].pressure == 0){particles[j].pressure = 1;}
                normal += normalize((positionj - positioni)) * -(945/(32*PI)*(pow(SMOOTHING_LENGTH,9)))*(pow(SMOOTHING_LENGTH,2)-pow(r,2));
                gradient += -(PARTICLE_MASS/particles[j].density)*(945/(32*PI)*(pow(SMOOTHING_LENGTH,9)))*(pow(SMOOTHING_LENGTH,2)-pow(r,2))*(3*pow(SMOOTHING_LENGTH,2) - 7*(pow(r,2)));
            }
}
        modgradient = length(normal);
        if(modgradient<(0.1/SMOOTHING_LENGTH)){surface_force = vec3(0,0,0);}
        else{
        surface_force = 0.1*(normal)*gradient/modgradient;
        }
} 

    

    
    viscosity_force *= PARTICLE_VISCOSITY;

    external_force = particles[i].density* GRAVITY ;//+ (particles[i].density-1000)* GRAVITY;

    particles[i].forcex = pressure_force.x + viscosity_force.x + external_force.x + surface_force.x ;
    particles[i].forcey = pressure_force.y + viscosity_force.y + external_force.y + surface_force.y ;
    particles[i].forcez = pressure_force.z + viscosity_force.z + external_force.z + surface_force.z;
    particles[i].correction_forcex = (correction_pressure_force.x + correction_viscosity_force.x + external_force.x);
	particles[i].correction_forcey = (correction_pressure_force.y + correction_viscosity_force.y + external_force.y);
    particles[i].correction_forcez = (correction_pressure_force.z + correction_viscosity_force.z + external_force.z);
	
}
