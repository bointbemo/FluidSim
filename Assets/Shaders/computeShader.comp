#version 440

#define WORK_GROUP_SIZE 7200
#define NUM_PARTICLES 7200
#define PARTICLE_RADIUS 0.1f

// For calculations
#define PI 3.141592741f


#define TIME_STEP 0.01f
#define WALL_DAMPING 0.3f
layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct Particle
{
 	        float x; //position
			float y;
			float z;
			
			
			float velocityx;//velocity
			float velocityy;
			float velocityz;
		
			float forcex;//force
			float forcey;
			float forcez;
			
			
			float density;//density
			float dempty;
			
			float pressure;//presure
			float pempty; //llambda

			float correction_forcex;
			float correction_forcey;
			float correction_forcez;
    
};

layout(std430, binding = 1) buffer PARTICLES
{
Particle particles[];
};



const float GAS_CONST = 2.0f; // const for equation of state

void main()
{
    uint i = gl_GlobalInvocationID.x;
int boundary = 10;
vec4 posshift = vec4(0,0,0,0);
    // integrate
    if(particles[i].density < 0.01){particles[i].density = 100;};
   
  

    vec4 acceleration = vec4(particles[i].forcex,particles[i].forcey,particles[i].forcez,0) / particles[i].density ;

    vec4 new_velocity = ((vec4(particles[i].velocityx,particles[i].velocityy,particles[i].velocityz,0)+ (TIME_STEP+TIME_STEP/2) * acceleration) + 
    (vec4(particles[i].velocityx,particles[i].velocityy,particles[i].velocityz,0)+ (TIME_STEP-TIME_STEP/2 * acceleration)))/2;

     if(new_velocity.x>2000 ){new_velocity.x = 2000;};
    if(new_velocity.x<-2000){new_velocity.x = -2000;};
     if(isinf(new_velocity.x) == true){new_velocity.x = particles[i].velocityx;};

     if(new_velocity.y>2000){new_velocity.y = 2000;};
    if(new_velocity.y<-2000){new_velocity.y = -2000;};
    if(isinf(new_velocity.y) == true){new_velocity.y = particles[i].velocityy;};
     
     if(new_velocity.z>2000){new_velocity.z = 2000;};
    if(new_velocity.z<-2000){new_velocity.z = -2000;};
  if(isinf(new_velocity.z) == true){new_velocity.z = particles[i].velocityz;};
  
    vec4 new_position = vec4(particles[i].x,particles[i].y,particles[i].z,0) + TIME_STEP * new_velocity;

   

   if(particles[i].dempty == 1){
    vec4 correction_acceleration = vec4(particles[i].correction_forcex,particles[i].correction_forcey,particles[i].correction_forcez,0) / 1000;
    vec4 correction_velocity = vec4(particles[i].velocityx,particles[i].velocityy,particles[i].velocityz,0)+ TIME_STEP * acceleration;
    vec4 correction_position = vec4(particles[i].x,particles[i].y,particles[i].z,0) + TIME_STEP * new_velocity;
    new_position = correction_position + new_position;
    particles[i].dempty = 1;
   }



    {
    // boundary conditions
   /*   if (new_position.x < -8) //-boundary)
    {
        new_position.x = -8; //-boundary;
        new_velocity.x *= -1 *WALL_DAMPING;
    }
    else if (new_position.x >  -3)// boundary)
    {
        new_position.x = -3; //boundary;
        new_velocity.x *= -1 *WALL_DAMPING;
    }
     if (new_position.y < -8) //-boundary)
    {
        new_position.y = -8 ;//-boundary;
        new_velocity.y *= -1* 0.01;
    }
    else if (new_position.y >-3) //boundary)
    {
        new_position.y = -3;//boundary;
        new_velocity.y *= -1 * WALL_DAMPING;
    }
       if (new_position.z < -8 )//-boundary)
    {
        new_position.z = -8 ;//-boundary;
        new_velocity.z *= -1 * WALL_DAMPING;
    }
    else if (new_position.z > -3) // boundary)
    {
        new_position.z = -3 ;//boundary;
        new_velocity.z *= -1 * WALL_DAMPING;
    }  */
      if (new_position.x < -boundary)
    {
        new_position.x = -boundary;
        new_velocity.x *= -1 *WALL_DAMPING;
    }

    else if (new_position.x > boundary)
    {
        new_position.x = boundary;
        new_velocity.x *= -1 *WALL_DAMPING;
    }
     if (new_position.y <-boundary)
    {
        new_position.y = -boundary;
        new_velocity.y *= -1* 0.01;
    }
    else if (new_position.y >boundary)
    {
        new_position.y = boundary;
        new_velocity.y *= -1 * WALL_DAMPING;
    }
       if (new_position.z < -boundary)
    {
        new_position.z = -boundary;
        new_velocity.z *= -1 * WALL_DAMPING;
    }
    else if (new_position.z >  boundary)
    {
        new_position.z = boundary;
        new_velocity.z *= -1 * WALL_DAMPING;
    } 



    particles[i].velocityx = new_velocity.x;
    particles[i].velocityy = new_velocity.y;
    particles[i].velocityz = new_velocity.z;
    particles[i].x = new_position.x;
    particles[i].y = new_position.y;
    particles[i].z=  new_position.z;
}
}